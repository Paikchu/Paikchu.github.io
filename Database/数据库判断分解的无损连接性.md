## 数据库判断分解的无损连接性（lossless join）



关系模式 R(A,B,C,D,E) F{A->C, C->D, B->C, DE->C, CE->A}.

若分解成R1(AD), R2(AB), R3(BC), R4(CDE), R5(AE)



#### 构建矩阵

将关系中包含的填为a，剩余的填为b

|      | A    | B    | C    | D    | E    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| AD   | a1   | b12  | b13  | a4   | b15  |
| AB   | a1   | a2   | b23  | b24  | b25  |
| BC   | b31  | a2   | a3   | b34  | b35  |
| CDE  | b41  | b42  | a3   | a4   | a5   |
| AE   | a1   | b52  | b53  | b54  | a5   |



#### 根据FD来扫描矩阵中的值

例：第一个FD{A->C}

找出所有A列相同的tuple，修改对应的C列。

​	A列相同的tuple中，C列包括a，则将相同的都修改为a

​	否则修改b

|      | A      | B    | C       | D    | E    |
| ---- | ------ | ---- | ------- | ---- | ---- |
| AD   | ==a1== | b12  | ==b13== | a4   | b15  |
| AB   | ==a1== | a2   | ==b13== | b24  | b25  |
| BC   | b31    | a2   | a3      | b34  | b35  |
| CDE  | b41    | b42  | a3      | a4   | a5   |
| AE   | ==a1== | b52  | ==b13== | b54  | a5   |

第二个FD{C->D}，做上面相同的操作

|      | A    | B    | C       | D      | E    |
| ---- | ---- | ---- | ------- | ------ | ---- |
| AD   | a1   | b12  | ==b13== | ==a4== | b15  |
| AB   | a1   | a2   | ==b13== | ==a4== | b25  |
| BC   | b31  | a2   | ==a3==  | ==a4== | b35  |
| CDE  | b41  | b42  | ==a3==  | ==a4== | a5   |
| AE   | a1   | b52  | ==b13== | ==a4== | a5   |

直到将所有的函数依赖遍历完

#### 判断是否为lossless join

1. 如果找到一行，全部为a，则证明是lossless join

2. 如果不存在全为a的一行

   + 判断当前遍历FD的过程中，是否修改了矩阵中的元素，如果修改了，则再次进行一次FD遍历，直到没有修改

   + 如果没有修改，且找不到全为a的一行，则证明不是lossless join