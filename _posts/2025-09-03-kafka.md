---
layout: post
title:  "Kafka common questions"
date:   2025-09-03 10:34:05 +0800
categories: kafka
---

kafka如何保证顺序消费

### Kafka实现广播

1. 使用不同的消费者Group ID：适用于广播消息

### 多分区消费者选择策略

多个partition如何选择：

1. 轮询
2. hash根据key来判断走哪个消费者

### 一般该如何配置分区和消费者数量

1. 同一消费者组内的消费者会被分配到不同的分区，1个分区只能被同组内一个消费者消费
2. 消费者实例数量应该小于分区数量
3. 根据吞吐量需求分配，需要确保有一定量的冗余
4. 数据均衡性：分区数量最好是实例数量的整数倍，不然实例之间的负载差距较大
5. 动态扩容，高峰期增加服务实例数量，低谷期可以再缩容
6. 实例数最小为2，避免单实例故障

### Group ID

- 同一 Group ID → 负载均衡（分担消费同一个topic，避免重复）。
- 不同 Group ID → 独立消费（广播，全量接收）。合理设计 Group ID 是实现 Kafka 消息分发策略（负载均衡 / 广播）的关键。

为什么有topic的情况下，还需要group ID？

1. 避免重复消费：为了确保，一条消息只被单一消费者消费，防止出现重复消费。
2. 实现负载均衡：Topic内实现负载均衡
3. 利用分区并行性：避免多个消费者同时消费一个分区的内容

通过不同的group ID实现广播：同一个topic下的消息会被每个group进行消费。

group ID还可以用来跟踪消费进度，每个分区会维护一个当前分区，该group消费到的位置，重启后继续消费，避免消息丢失。

### kafka 如何实现顺序消费

1. 确保需要保持顺序的业务的消息，进入相同的分区：通过指定key的方式，将消息送入相同的分区，前面提到有key的情况下走hash key，没有的情况下走轮询
2. 消费者单线程处理：进入相同分区，就只会被一个消费者消费，所以没有多消费者消费相同消息的情况。此时只需要保证消费者单线程处理就可以保证有序。
3. 避免生产者重试：有重试机制，在出现发送失败的情况下会重试，重试过程中发送的消息可能落后于后面到来的消息。
    1. 配置 `max.in.flight.requests.per.connection = 1`（限制单个连接同时发送的未确认请求数为 1），确保前一条消息处理完成（成功 / 失败）后，再发送下一条。
    2. 牺牲并发能力
4. **处理分区重分配时的顺序性：**当消费者组发生变化（如实例增减、崩溃重启），Kafka 会触发**分区重分配**（Rebalance）。若处理不当，可能导致消息重复或顺序混乱。保障措施：
    - 依赖 Kafka 的**偏移量（Offset）机制**：重分配后，消费者从最新提交的 Offset 继续消费，避免重复处理已消费的消息。
    - 关闭自动提交 Offset（`enable.auto.commit = false`），改为**消费完成后手动提交**，确保消息处理成功后再记录 Offset。

### 关于为什么使用kafka而不是别的MQ

1. 高吞吐：大数据场景，我们用来收集日志
    1. 分区并行
    2. 批量读写
    3. 零拷贝
2. 可靠
    1. 强持久化：通过ack机制确保持久化到磁盘
    2. 多副本
3. 适合大数据流处理

但是在死信队列等方面的支持不是很好。