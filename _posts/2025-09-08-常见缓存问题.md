---
layout: post
title: 缓存穿透&缓存击穿&缓存雪崩
categories: Redis
date: 2025-09-08
---
### 缓存穿透

定义：

客户端请求的数据在缓存和数据库中都不存在，缓存永远不会生效，永远会打到数据库上。

可以搞服务攻击，故意发送不存在的请求，冲击数据库。

![image.png](/assets/2025-09-08-常见缓存问题/image.png)

解决方案：

1. 缓存空对象：缓存null。
    1. 优点：实现简单，维护方便
    2. 缺点：
        1. 额外内存消耗（设置短TTL）
        2. 可能造成短期不一致。比如用户请求一个空id，设置为null。当刚好有创建出来一个相同的id，就会出现短期不一致。
2. 布隆过滤：将数据计算出hash值，转换为2进制位存在过滤器中，并不是百分百准确，还是有穿透可能。
    
    添加一个过滤器在客户端和Redis之间，先判断是否数据存在。
    
    1. 优点：内存占用少，没有多余key
    2. 缺点：实现复杂，存在误判可能
3. 提高id复杂度
4. 增强数据格式校验
5. 增强用户权限管理
6. 热点参数限流

![image.png](/assets/2025-09-08-常见缓存问题/image%201.png)

![image.png](/assets/2025-09-08-常见缓存问题/image%202.png)

### 缓存击穿（缓存失效）热点key问题

### 定义

缓存击穿是指**某个热点数据在缓存中过期时**，大量并发请求同时访问这个数据，导致所有请求都直接打到数据库上，造成数据库瞬时压力过大甚至崩溃。

场景：

1. 单个热点key突然失效，且缓存重建困难，在这个重建过程中依旧有众多线程到达数据库，每个线程都在尝试重建数据库
2. Redis宕机

### 特点

- 针对**单个热点key**
- 发生在key刚好过期的瞬间
- 并发量非常大

解决方案：

- 采用互斥锁，限制只有一个线程能访问数据库，来重建缓存：缺点就是，时间较长，未获取到锁的存在逻辑等待，等到获取成功才继续
    - 没有内存消耗，不需要维护一个逻辑过期字段
    - 保证一致性
    - 实现简单
    - 性能不好
    - 有死锁风险

![image.png](/assets/2025-09-08-常见缓存问题/image%203.png)

- 互斥锁 + 设置缓存逻辑过期：设置一个expire的字段，不是TTL字段，针对活动场景
    - 性能好，线程无等待
    - 不保证绝对一致性
    - 有额外内存消耗
    - 实现复杂
    
    ![image.png](/assets/2025-09-08-常见缓存问题/image%204.png)
    

### 缓存雪崩

### 定义

缓存雪崩是指**大量缓存数据在同一时间过期**，导致所有请求都直接访问数据库，造成数据库压力激增甚至崩溃。

### 特点

- 影响**大量key**
- 发生在缓存大规模失效时
- 比缓存击穿影响范围更大

### 解决方案

1. **随机过期时间**：设*置基础过期时间+随机时间*

```java
int expireTime = 3600 + random.nextInt(600);// 1小时±10分钟
cache.set(key, value, expireTime);
```

1. **多级缓存**：
    1. 本地缓存 + 分布式缓存
    2. 不同层级设置不同过期策略
2. **缓存预热**：
    1. 系统启动时加载热点数据到缓存
    2. 避免冷启动问题
3. **熔断降级**：
    1. 当数据库压力过大时
    2. 快速返回默认值或错误页面

| **特征** | **缓存击穿** | **缓存雪崩** |
| --- | --- | --- |
| 影响范围 | 单个热点key | 大量key同时失效 |
| 发生时机 | 热点key过期瞬间 | 缓存大规模失效时刻 |
| 并发量 | 针对该key的高并发 | 系统整体高并发 |
| 解决方案 | 互斥锁、逻辑过期 | 随机过期、多级缓存 |

解决方案：

1. 给不同的Key的TTL添加随机的过期时间
2. 采用Redis集群提高服务可用性
3. 给缓存业务添加降级限流策略：在Redis不可用的情况下，做快速失败，防止全部冲击数据库 Sentinel
4. 给业务添加多级缓存

### 热点缓存Key重建优化

平时没有人购买的商品，信息没有缓存，但突然到来了超多请求，同时触及到存储层。

此时，超多的线程在重建缓存，导致后端负载加大，甚至应用崩溃。、

目标避免大量线程同时重建缓存。

只允许一个线程重建缓存，其他线程等待缓存执行完毕，从缓存获取数据即可。

通过加锁限制，只有一个线程能直接访问数据库。

![image.png](/assets/2025-09-08-常见缓存问题/image%205.png)