---
date: 2025-09-08
layout: post
categories: Redis
title: Redis
---
### 为什么Redis性能高？

1. 内存操作
2. 单线程模型：没有线程进程切换消耗
3. 多路复用 IO：epoll
4. 底层高效性能结构：全局哈希表

### Redis是什么？有什么用？

Remote Dictionary Server

Key value数据库

缓存的作用：

- 降低后端负载
- 提高读写效率，降低响应时间

缓存的成本：

- 数据一致性问题
- 代码维护
- 运维成本

核心总结：

- 数据结构复杂：支持多种数据类型，不止能用于缓存
- 数据保存在内存，但是持久化到硬盘

缓存更新策略：

|      | 内存淘汰                        | 超时剔除               | 主动更新           |
| ---- | --------------------------- | ------------------ | -------------- |
| 说明   | Redis自己内部维护，当内存满的时候自己淘汰部分数据 | 给缓存设置TTL时间，到时间自动删除 | 修改数据库的时候同时更新缓存 |
| 一致性  | 差                           | 一般                 | 好              |
| 维护成本 | 无                           | 低                  | 高              |

### 主动更新策略

1. Cache Aside: 调用者在更新数据库的时候同时更新缓存
    1. 删除缓存还是更新缓存
        1. 更新缓存：每次更新数据库都更新缓存，无效写操作较多
        2. 删除缓存：更新数据库时让缓存失效，查询时再更新缓存
    2. 如何保证缓存与数据库的操作同时成功或失败
        1. 单体系统：缓存和数据库放在一个事务中
        2. 分布式系统：利用TCC等分布式事务方案
    3. 先操作缓存还是数据库
        1. 先删除缓存，再操作数据库（出现不一致的可能性较高，因为操作数据库较慢）：
            
            ![image.png](/assets/2025-09-08-Redis/image.png)
            
        2. 先操作数据库，再删除缓存（可能性比较低，缓存操作快）：会出现一致性问题，查询数据在更新数据库之前，导致后续缓存更新的时候被写入旧的数据
            
            ![image.png](/assets/2025-09-08-Redis/image%201.png)
            
    4. 延时双删
        1. **第一次删除**：在更新数据库之前，先删除缓存中的旧数据
        2. **执行数据库更新**：完成数据库的更新操作
        3. **延时后第二次删除**：等待一段时间后，再次删除缓存
2. Read/Write Through Pattern: 把缓存与数据库的操作维护作为一个service，这样其他服务调用就不需要管缓存和数据库的一致性。
3. Write behind caching pattern调用者只操作缓存，由其他的线程异步将缓存中的内容，同步到数据库中

### 最佳实践方案：

1. 低一致性需求：使用Redis自带的内存淘汰机制
2. 高一致性需求：主动更新，并以超时提出作为兜底方案
    1. 读操作：
        1. 缓存命中直接返回
        2. 未命中查询数据库，写入缓存，设置超时时间
    2. 写操作：
        1. 先写数据库，再删除缓存
        2. 要保持操作原子性

[2025-09-08-常见缓存问题](2025-09-08-常见缓存问题.md)

## 深入理解Redis线程模型

### Redis是单线程还是多线程

客户端多线程，服务端单线程，采用epoll进行IO多路复用，通过一个主线程响应多个客户端线程的socket的连接请求。

![image.png](/assets/2025-09-08-Redis/image%202.png)

优势：由于redis将客户端的并发请求转为串型执行，因此可以避免很多脏读等问题的出现

采用内存的高性能模型，让其可以用于解决很多并发问题。

为什么不急于想多线程改进，因为性能瓶颈通常不出在CPU上，内存和网络是更大的瓶颈

> 多线程改进：到Redis6.x和7.x版本中，开始⽤⼀种全新的多线程机制来提升后台⼯作。尤其在现在的Redis7.x版本中，Redis后端的很多⽐较费时的操作，⽐如持久化RDB，AOF⽂件、unlink异步删除、集群数据同步等，都是由额外的线程执⾏的。例如，对于 FLUSHALL操作，就已经提供了异步的⽅式
> 

### Redis如何保持指令原子性

读写KV的操作无法保证原子性

![image.png](/assets/2025-09-08-Redis/image%203.png)

1. 采用复合指令

Redis内部提供了很多复合指令，他们是⼀个指令，可是明显⼲着多个指令的活。⽐如 MSET(HMSET)、GETSET、SETNX、SETEX。这些复合指令都能很好的保持原⼦性。

1. Redis事务

开启事务可以确保事务内所有的原子操作被一起执行。

不会存在，事务1和事务2中的操作交叉执行的情况，例如上图。

### 事务失败如何回滚

如果存在多个执行操作，但其中有操作失败的情况下，并不会让整个事务回滚。

例如：lpop k2是对于list的操作，无法在string上操作，导致后面的所有内容失败，但前面已经执行过的内容不会回滚。

![image.png](/assets/2025-09-08-Redis/image%204.png)

通过添加WATCH k2，监控k2在事务执行开始前或者后不能被修改，从而确保事务的成功是可控的。如果k2在其中被修改，那么事务会直接失败。

### 事务执行过程中出现失败

1. 只要客户端执行了EXEC指令，即便客户端断开了也会继续执行下去
2. 事务可能出现数据不一致。EXEC之后，会先将事务中的所有操作记录在AOF文件中，用于后续持久化。如果在记录完AOF，但未能实际操作数据库的过程中服务器崩溃，可能出现日志和数据库数据对不齐的问题，使用redis-check-aof工具来修复AOF文件，将不完整的事务移除。

### Redis pipeline

从stdout中获取执行命令，并执行。

直接传一个文件，文件中有操作命令，直接送到redis中执行。性能稍微有提升，由于这个操作降低RTT时间（Round Trip Time）：减少客户端和服务端沟通操作。指令会现在客户端缓存，一次性的发送给服务端，从而降低RTT。指令越多越明显。

不具备原子性，不保证一起成功一起失败，只保证指令一起执行

![image.png](/assets/2025-09-08-Redis/image%205.png)

### Lua脚本

上述的Redis事务和Pipeline机，针对Redis的指令原子性的问题，有帮助，但解决的都不好，且没法添加复杂的运行逻辑。企业中更多用Lua脚本，Redis7的重要特性。

LuatOS

比如在分布式锁中，set key和设置过期时间要进行原子性操作。

### Redis Function

可以直接将function加载到服务端，客户端可以直接调用

### Redis中的Bigkey问题

BigKey是那些占用空间非常大的Key，例如存储一篇文章，或者list中包含200w的元素。这个BigKey在单线程中容易造成系统阻塞。可以使用--bigkey进行排查

总结

Redis整体是多线程的，但执行指令的核心线程是单线程的。Redis这种简单的线程模型，不利于发挥多线程并发优势

## Redis 分布式锁

### SETNX + delete 实现分布式锁

存在如下问题：

1. 无法确保SETNX操作和Expire操作的原子性
2. 正常情况下一定在finally中释放，如果服务器宕机，则key无法释放。过期时间为了确保不会出现锁一直被占有的问题
3. 如果业务逻辑执行时间大于10秒，锁已经过期了，此时如果走到finally，则有可能把其他线程新加的锁给删掉

```java
@RequestMapping("/deduct_stock")
public String deductStock() {
    String lockKey = "lock:product_101";
    Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "zhuge");
    stringRedisTemplate.expire(lockKey, 10, TimeUnit.SECONDS);
    if (Boolean.FALSE.equals(result)) {
        return "error_code";
    }
    try {
        int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock")); // jedis.get("stock")
        if (stock > 0) {
            int realStock = stock - 1;
            stringRedisTemplate.opsForValue().set("stock", realStock + ""); // jedis.set(key,value)
            System.out.println("扣减成功，剩余库存:" + realStock);
        } else {
            System.out.println("扣减失败，库存不足");
        }
    } finally {
        stringRedisTemplate.delete(lockKey);
    }
    return "end";
}

```

优化问题1: 确保SETNX和EXPIRE是原子操作，使用一条命令

```java
@RequestMapping("/deduct_stock")
public String deductStock() {
    String lockKey = "lock:product_101";
    Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "zhuge", 10, TimeUnit.SECONDS);
    if (Boolean.FALSE.equals(result)) {
        return "error_code";
    }
    try {
        int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock")); // jedis.get("stock")
        if (stock > 0) {
            int realStock = stock - 1;
            stringRedisTemplate.opsForValue().set("stock", realStock + ""); // jedis.set(key,value)
            System.out.println("扣减成功，剩余库存:" + realStock);
        } else {
            System.out.println("扣减失败，库存不足");
        }
    } finally {
        stringRedisTemplate.delete(lockKey);
    }
    return "end";
}

```

优化问题3: 设置一个UUID为value，当判断value相同的情况下再删除。

暴露新问题：如果在`if(clientId.equals(stringRedisTemplate.opsForValue().get(lockKey)))`后正好到过期时间了，就会出现delete异常

```java
@RequestMapping("/deduct_stock")
public String deductStock() {
    String lockKey = "lock:product_101";
    String clientId = UUID.randomUUID().toString();
    Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, clientId, 10, TimeUnit.SECONDS);
    if (Boolean.FALSE.equals(result)) {
        return "error_code";
    }
    try {
        int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock")); // jedis.get("stock")
        if (stock > 0) {
            int realStock = stock - 1;
            stringRedisTemplate.opsForValue().set("stock", realStock + ""); // jedis.set(key,value)
            System.out.println("扣减成功，剩余库存:" + realStock);
        } else {
            System.out.println("扣减失败，库存不足");
        }
    } finally {
        if(clientId.equals(stringRedisTemplate.opsForValue().get(lockKey)))
            stringRedisTemplate.delete(lockKey);
    }
    return "end";
}

```

Permission Service的分布式锁 SETNX

`SETNX key: 业务名称  value: 资源的UUID timeout: 10s`

上锁流程：设置完成后 → 会马上get方法，如果返回的value是同一个UUID则获取锁成功，否则失败

业务执行完成后 → finally中释放锁

释放锁流程：检查Redis中的值是否还是这个UUID，如果是则delete，否则不管

使用redisson锁

```java
@RequestMapping("/deduct_stock")
public String deductStock() throws InterruptedException {
    String lockKey = "product_001";
    RLock redissonLock = redisson.getLock(lockKey);
    try {
        // 加锁，实现锁续命功能
        redissonLock.lock();
        int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock")); // jedis.get("stock")
        if (stock > 0) {
            int realStock = stock - 1;
            stringRedisTemplate.opsForValue().set("stock", realStock + ""); // jedis.set(key,value)
            System.out.println("扣减成功，剩余库存:" + realStock + "");
        } else {
            System.out.println("扣减失败，库存不足");
        }
    }finally {
        redissonLock.unlock();
    }
    return "end";
}

```

### Redisson锁源码解析

![image.png](/assets/2025-09-08-Redis/image%206.png)

**加锁**

执行tryAcquire()

![image.png](/assets/2025-09-08-Redis/image%207.png)

![image.png](/assets/2025-09-08-Redis/image%208.png)

![image.png](/assets/2025-09-08-Redis/image%209.png)

执行lua脚本加锁，加锁成功返回nil

```
"if (redis.call('exists', KEYS[1]) == 0) then " +
    "redis.call('hset', KEYS[1], ARGV[2], 1); " +
    "redis.call('pexpire', KEYS[1], ARGV[1]); " +
    "return nil; " +
"end;

```

**自动续锁机制**

获取到锁的线程如何实现看门狗机制，从而自动续锁，当业务执行时间大于锁的TTL的情况下

![image.png](/assets/2025-09-08-Redis/image%2010.png)

当锁加成功后，执行shcduleExpirationRenewal方法，delay时间到了后执行续命Lua脚本。Lua脚本判断主线程加的锁是否还存在，如果还在则加30秒。当续命成功后，再调用scheduleExpirationRenewal的续命方法，等待下一次续命。

> 为什么通过方法嵌套调用来实现锁续命，而不是使用的Java Timer定时器方法来实现定时任务，一般都使用方法嵌套的方法实现定时任务。时间间隔可控。。
> 

![image.png](/assets/2025-09-08-Redis/image%2011.png)

锁如何被触发释放

锁自旋如何实现

直接进入while（true）循环，自旋获取锁，

当尝试获取锁成功的话，跳出循环

如果锁获取不成功

![image.png](/assets/2025-09-08-Redis/image%2012.png)

采用信号量机制获取锁

![image.png](/assets/2025-09-08-Redis/image%2013.png)

### 续锁失败的可能原因

- Redisson客户端与Redis连接断开，心跳保活失败
- 客户端宕机、崩溃或进程被kill，看门狗
- 网络抖动，导致心跳和续期命令执行失败

### 续锁失败后的后果

- 锁到期释放问题：导致锁提前释放，被其他线程获取到，导致资源出现并发访问问题
- 数据不一定：可能多个线程访问相同的资源，导致数据不一致风险。例如订单库存扣减的场景中，可能导致库存被错误扣减
- 死锁风险（特定场景）：业务设计不当，例如未正确释放锁，续锁又失败，导致资源被卡死

### 如何应对Redisson续锁失败的问题

1. 设置合理的锁过期时间
2. 增加容错机制
3. 监控Redisson的锁状态
4. 使用多副本Redis以提升可靠性

**面试题目：Redisson加锁失败，WatchDog是否会一直续期下去**

### Redis分布式锁和Zookeeper分布式锁的区别

### Red Lock

实现原理：SETNX方法对三个分布式节点都执行一次，当超过半数的加锁成功，客户端才执行加锁操作。这样下个线程再来的情况下，无法加锁成功，因为不可能大于半数都加锁成功。

![image.png](/assets/2025-09-08-Redis/image%2014.png)

## 京东热点缓存探测系统JDhotkey架构剖析

### 多级缓存架构在大厂中的实践

![image.png](/assets/2025-09-08-Redis/image%2015.png)

### 使用本地缓存 使用JVM缓存 的好处

1. 减少网络请求，提高性能
2. 天然分布式
3. 降低远程缓存读压力，防止雪崩导致冲击数据库

### 本地缓存的缺点

1. 进程空间有限，不支持大数据量 -> 存热点数据 类似像LRU算法之类的
2. 重启会丢失数据 -> 从 mysql中读取一份回来
3. 分布式场景，系统之间数据不一致
4. 和远程缓存数据存在不一致

### 什么场景下需要用到多级缓存

- 热点商品详情页
- 热搜
- 热门帖子
- 热门用户主页

### 热点探测服务的原理和实现

短时间内推高的流量 -> 热点

1. 秒杀，爆品
2. 黑客攻击，突发新闻导致的

热点探测使用场景：

- MySQL中被频繁访问的数据，热门商品的id
- Redis中被密集访问的Key
- 恶意攻击的特定的userId，IP地址
- 频繁被访问的接口地址

### 热点探测的好处

提升性能，规避风险

1. 数据层的风险：由于单线程的原因导致请求排队，导致分片集群压力过载瘫痪
2. 应用服务的风险：恶意请求，挤压正常请求

### 如何实现热点探测

基于滑动窗口的检测器，检测在单个时间窗口内，访问的总数，通过一个集合存放热key

对于分布式系统，需要一个独立的集中的热Key计算单元

具体的操作步骤：分布式应用节点感知热点规则配置，将热点数据上报，工作节点进行热点数据统计，符合阈值的推送给客户端，应用收到的热点信息进行本地缓存。

[Redis6.0为什么引入多线程](Redis%201019563e379880d4adddf8b95558e28d/Redis6%200%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%2023a9563e379880c9a592e64ea82d2749.md)

[Lettuce](assets/2025-09-08-Redis/Lettuce%202469563e3798809498d6c88927ee5743.md)

## Redis持久化

Redis作为一个高性能的键值存储系统，其数据通常存储在内存中，为了防止数据在服务重启后丢失，Redis提供了两种持久化策略：RDB（Redis DataBase）和AOF（Append Only File）。

### **RDB持久化**

RDB持久化是通过创建内存数据集的快照来实现的。这些快照会在配置的时间间隔内自动保存到磁盘上。RDB是一种非常高效的持久化方式，可以快速地保存和恢复大量数据。但是，它有一个缺点，就是在两次快照之间的数据可能会丢失。

**RDB的触发方式**：

- **手动触发**：可以通过*save*命令或*bgsave*命令来手动触发RDB持久化。*save*命令会阻塞Redis服务器，直到RDB文件创建完毕，而*bgsave*命令则会在后台创建一个子进程来生成RDB文件，不会阻塞主服务器进程。
- **自动触发**：在Redis配置文件中，可以通过*save*指令设置自动触发RDB持久化的条件，例如*save 900 1*表示900秒内如果至少有1个键被修改，则自动执行RDB持久化。

### **AOF持久化**

AOF持久化是通过记录每次写操作命令来实现的。这些命令会被追加到AOF文件中，当Redis重启时，可以通过重新执行这些命令来恢复数据。AOF提供了更好的数据完整性保障，但是相比RDB，AOF文件通常更大，且恢复速度较慢。

**AOF的触发方式**：

- **自动触发**：AOF持久化可以通过设置*appendfsync*指令来控制数据写入磁盘的频率。例如，*appendfsync everysec*表示每秒同步一次数据到磁盘。
- **重写机制**：为了减少AOF文件的大小，Redis提供了AOF重写机制，可以在不改变数据完整性的前提下，压缩AOF文件。

**混合持久化**

在Redis 4.0及以上版本中，引入了混合持久化模式，它结合了RDB和AOF的优点。在这种模式下，AOF重写时会将RDB格式的数据写入AOF文件的开头，然后将新的AOF命令追加到文件末尾。这种方式可以在提供数据完整性保障的同时，加快数据恢复速度。

**选择合适的持久化策略**

选择合适的持久化策略需要根据具体的业务需求和场景来决定。如果需要快速恢复数据且可以接受短时间内的数据丢失，RDB可能是更好的选择。如果对数据完整性有更高要求，AOF可能更适合。混合持久化则提供了两者的平衡。

在配置Redis持久化时，还需要考虑内存使用、磁盘使用、性能与持久性等多个因素，以确保既能满足业务需求，又能保证系统的稳定性和效率。

## Redis是单独部署在服务器上还是和项目跑在一个服务上

推荐：Redis单独部署

1. 资源隔离，避免和服务器出现内存竞争
2. 确保Redis运行稳定性
3. 扩展灵活
4. 安全性与权限控制

优化：

1. 快速内存
2. 网络优化
3. 高可用：集群部署